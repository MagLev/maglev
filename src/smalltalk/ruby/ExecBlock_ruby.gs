!=========================================================================
! Copyright (C) VMware, Inc. 2008-2011.  All Rights Reserved.
!
! $Id$
!
!  additional methods  for ExecBlock to support Ruby 
!=========================================================================

set class ExecBlock

! adding additional methods , don't 'removeallmethods'

category: 'Ruby support'

method:
_copyForRuby: opcode newBlockMethsInto: anArray
 "opcode == 0 , copy receiver for use in Proc.new_lambda .
   if receiver does not have lambda bit set, return a copy
   of receiver with lambda bit set, otherwise return receiver.

  opcode is a Symbol , copy receiver and it's VariableContext (if any)
   for use in a Ruby define_method  , aSymbol is the
   selector prefix for the new method (used to transform SUPER sends),
   and new methods created for copied blocks are stored into anArray
   so caller can fix up inClass .

  opcode == 2,  copy receiver for use in Proc.new 
 "
 <primitive: 678>
 ^ self _primitiveFailed: #_copyForRuby:newBlockMethsInto:
        args: { opcode . anArray }
%

method:
_copyForProc: opcode
 "opcode == 0 , copy receiver for use in Proc.new_lambda .
  opcode == 2,  copy receiver for use in Proc.new
 "
  ^ self _copyForRuby: opcode newBlockMethsInto: nil 
%

method:
_rubyCall: anArg
  "Bridge methods for 'call*' are used but call*  should compile to
   a SEND_CALL_STAR bytecode and never get here."
  self error:'should not be in ExecBlock>>_rubyCall: '
%

method:
_rubyCall: args block: blockArg
  "Sent from code generated for a ruby define_method"
<primitive: 2002>
args _validateClass: Array .
blockArg _validateClass: ExecBlock .
^ self _primitiveFailed: #_rubyCall:block: args: { args . blockArg }
%

! see ASSUME_envId1 in  src/intswitch.c  for places where envId==1 is 
!  assumed in handling of an Exception for a Ruby rescue on a Module .
!
category: 'Block Evaluation'
method: 
rescue1: anExceptionClass do: handlerBlock
 "Try to evaluate the receiver, which should be a zero-argument block.
  If an exception occurs which is matched by anExceptionClass,
  evaluate the one argument block handlerBlock , passing it the exception 
  instance as its argument.

  These forms are supported:
    (1) on: anException do: handlerBlock
    (2) on: anArray     do: handlerBlock
    (3) on: anExceptionSet do: handlerBlock
    (4) on: anArray     do: anArrayOfBlocks

  In form 1 , if anException==Object, it is silently changed on the stack
  to Exception .
  In form 3 or 4, if an element of anArray or anExceptionSet is == Object, 
  that element is silently changed to Exception , 
  and anArray is assumed to be a temporary array,
  per code generated by RubyRescueBodyNode and RubyRescueNode in .mcz.

  anException must be the class Exception  or a subclass thereof ,
    or a Module .
  anExceptionSet must be a kind of ExceptionSet;
  anArray must be a kind of Array ;
  handlerBlock must be an instance of ExecBloc ; if any of these
  is violated, the send of on:do: will fail with an error.

  anArrayOfBlocks must be an Array containing instances of ExecBloc ,
  the elements are not checked during the on:do: send , and are only
  checked if they are attempted to be evaluated during exception handling.
  
  In forms 2,3,4 elements of anArray or anExceptionSet which
  are not a kind of Exception, or a Module, 
  or an Array containing kinds of Exception or Modules ,
  will silently have no effect on catching exceptions.

  In form 4, elements of anArray may in turn be Arrays of Exceptions.
  In form 4, the offset of the first element of anArray containing a 
  match to a signaled exception defines the offset in anArrayOfBlocks
  at which to find the handlerBlock to invoke.

  For forms 1,2,3 if handlerBlock expects more fewer than 1 argument,
  an error is generated if exception handling attempts to
  invoke that handlerBlock.  

  For form 4, elements of anArrayOfBlocks must be instances of ExecBlock,
  otherwise the corresponding entry in anArray will silently have no effect 
  on catching exceptions.  If an element of anArrayOfBlocks is an ExecBlock
  taking more or fewer than 1 argument, an error is generated if exception 
  handling attempts to invoke that block.

  If handlerBlock is invoked to handle an Exception which occurs during
  execution of the receiver and handlerBlock completes normally , then
  the result of handlerBlock (value of last expression in handlerBlock)
  will be the result of the on:do: send .  Other-than-normal
  completion of handlerBlock is available by use of 
  Exception's instance methods such as
    #return  #return:  #retry #retryUsing: #resume #resume: #pass #outer 
  within handlerBlock "

<primitive: 2026> "marks frame with Exception_Mark_NIL, always fails"
^ self @ruby1:value
%


method:
setSelf: anObject

"If receiver is a copying block containing a copy of self,
 copy receiver and change self in the copy, and return the copy;
 else return receiver."

<primitive: 797>
^ self _primitiveFailed: #setSelf: args: { anObject }
%

method:
_rubyVcGlobalAt: offset
"returns Ruby $~ or $_ , from receivers home context
  offset == 0 means $~ , 1 means $_  , 2 is eval lexical path
 If receivers home context  does not reference the specified
  variable, returns nil
"
| theVc |
theVc := staticLink .
theVc ifNotNil:[ | len frameLclMark |
  (offset <= 2) ifFalse:[
    self error:'arg to _rubyVcGlobalAt: must be 0..2 ' .
  ].
  len := theVc size .
  frameLclMark := theVc at: len .  "look for OOP_RUBY_FRAME_LOCALS_NIL"
  frameLclMark == _rubyFrameLocalsNil ifTrue:[
    ^ theVc at: len - 1 - offset
  ].
].
^ nil  
%

method:
_rubyVcGlobalAt: offset put: aValue

"Stores aValue into Ruby $~ or $_  of receivers home context,
  if the home context has a reference to that variable.
 returns receiver .
  offset == 0 means $~ , 1 means $_  , 2 is eval lexical path
"
| theVc |
theVc := staticLink .
theVc ifNotNil:[ | len frameLclMark |
  (offset <= 2) ifFalse:[
    self error:'arg to _rubyVcGlobalAt: must be 0..2 ' .
  ].
  len := theVc size .
  frameLclMark := theVc at: len .  "look for OOP_RUBY_FRAME_LOCALS_NIL"
  frameLclMark == _rubyFrameLocalsNil ifTrue:[
    theVc at: len - 1 - offset put: aValue
  ].
].
%
method:
_rubyInspect
  | str  |
  str := '#<' copy .  
  str addAll: self class name ;
     addAll: ':0x' ; addAll: self asOop hex ; add: $  .
  ^ str 
%

method:
_ruby_whileTrue: bodyBlock
   "invoked from generated code for RubyAbstractWhileNode, 
     conforms to Object>>_rubyEach1:  "
^ [
    [ self value ] @ruby1:whileTrue: [ bodyBlock value ]
  ] onException: RubyBreakException do: [:ex | | args | 
      args := ex gsArguments .
      (args at: 1) ifTrue:[  "Ruby break, terminate enumeration"
        ^ args at: 2
      ] ifFalse:[
        ex retry "Ruby retry,  restart the enumeration"
      ]
  ] . 
%
method:
_ruby_whileFalse: bodyBlock
   "invoked from generated code for RubyAbstractWhileNode, 
     conforms to Object>>_rubyEach1:  "
^ [
    [ self value ] @ruby1:whileFalse: [ bodyBlock value ]
  ] onException: RubyBreakException do: [:ex | | args | 
      args := ex gsArguments .
      (args at: 1) ifTrue:[  "Ruby break, terminate enumeration"
        ^ args at: 2
      ] ifFalse:[
        ex retry "Ruby retry,  restart the enumeration"
      ]
  ] . 
%

method:
_ruby_untilTrue: bodyBlock
   "invoked from generated code for RubyAbstractWhileNode, 
     conforms to Object>>_rubyEach1:  "
^ [
    [ bodyBlock value ] @ruby1:untilTrue: [ self value ]
  ] onException: RubyBreakException do: [:ex | | args | 
      args := ex gsArguments .
      (args at: 1) ifTrue:[  "Ruby break, terminate enumeration"
        ^ args at: 2
      ] ifFalse:[
        ex retry "Ruby retry,  restart the enumeration"
      ]
  ] . 
%

method:
_ruby_untilFalse: bodyBlock
   "invoked from generated code for RubyAbstractWhileNode, 
     conforms to Object>>_rubyEach1:  "
^ [
    [ bodyBlock value ] @ruby1:untilFalse: [ self value ]
  ] onException: RubyBreakException do: [:ex | | args | 
      args := ex gsArguments .
      (args at: 1) ifTrue:[  "Ruby break, terminate enumeration"
        ^ args at: 2
      ] ifFalse:[
        ex retry "Ruby retry,  restart the enumeration"
      ]
  ] . 
%

method:
forkAt: priority with: blockArgs env: envId
  "forks the receiver as a new process at the given priority"
  
  | proc |
  proc := GsProcess _forkBlock: self with: blockArgs env: envId .
  proc priority: priority .
  ^ proc 
%
